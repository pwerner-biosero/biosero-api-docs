---
id: CSharp Data Services Client
title: Data Services Client
---

import Protected from '@site/src/components/Protected';

<Protected>

# Data Services Client

The `DataServicesClient` class is the main HTTP client for interacting with the Biosero Data Services API. It provides a comprehensive interface for accessing analytics, application configurations, events, files, identities, and various laboratory data management services.

## üìã Table of Contents

- [üîç Overview](#-overview)
- [üì¶ Installation](#-installation)
- [üèóÔ∏è Constructor](#Ô∏è-constructor)
- [üìä Analytics Methods](#-analytics-methods)
- [‚öôÔ∏è Application Configuration Methods](#Ô∏è-application-configuration-methods)
- [üì¶ Event Management Methods](#-event-management-methods)
- [üìÅ File Management Methods](#-file-management-methods)
- [üß¨ Identity Management Methods](#-identity-management-methods)
- [ÔøΩ Individual Identity Operations](#-individual-identity-operations)
- [‚öñÔ∏è Weight and Volume Management](#Ô∏è-weight-and-volume-management)
- [ÔøΩüìä Laboratory Data Methods](#-laboratory-data-methods)
- [üîÑ Additional API Methods](#-additional-api-methods)
- [‚ö†Ô∏è Error Handling](#Ô∏è-error-handling)
- [üìñ Examples](#-examples)
- [üéØ Best Practices](#-best-practices)

## üîç Overview

The DataServicesClient is a generated HTTP client that provides strongly-typed access to the Biosero Data Services API. It handles HTTP communication, serialization/deserialization, and provides both synchronous and asynchronous methods for all API operations.

**Namespace:** `Biosero.DataServices.Client`  
**Generated by:** NSwag 14.5.0.0  
**Dependencies:** HttpClient, Newtonsoft.Json

### Key Features
- Auto-generated from OpenAPI/Swagger specifications
- Full async/await support with cancellation tokens
- Strongly-typed request/response models
- Comprehensive error handling with custom exceptions
- Built-in JSON serialization with customizable settings
- Support for file uploads and downloads
- Automatic HTTP header management

## üì¶ Installation

The Biosero Data Services Client is available as a NuGet package and can be installed using the .NET CLI, Package Manager Console, or by adding a PackageReference to your project file.

### .NET CLI

```bash
dotnet add package Biosero.DataServices.Client --version 2.0.1
```

### Package Manager Console

```powershell
Install-Package Biosero.DataServices.Client -Version 2.0.1
```

### PackageReference

Add the following to your `.csproj` file:

```xml
<PackageReference Include="Biosero.DataServices.Client" Version="2.0.1" />
```

### NuGet Package Manager

1. Right-click on your project in Visual Studio
2. Select "Manage NuGet Packages"
3. Search for "Biosero.DataServices.Client"
4. Install version 2.0.1

**Package Information:**
- **Package Name:** Biosero.DataServices.Client
- **Current Version:** 2.0.1
- **NuGet URL:** https://www.nuget.org/packages/Biosero.DataServices.Client
- **Target Framework:** .NET Standard 2.0+ / .NET Core 3.1+ / .NET 5.0+

### Dependencies

The package automatically includes the following dependencies:
- `Newtonsoft.Json` (‚â• 13.0.0)
- `System.Net.Http` (‚â• 4.3.0)
- `System.ComponentModel.Annotations` (‚â• 5.0.0)

## üèóÔ∏è Constructor

### DataServicesClient(HttpClient httpClient)

Creates a new instance of the DataServicesClient using the provided HttpClient.

**Parameters:**
- `httpClient` (HttpClient): The HTTP client instance to use for API communication

**Example:**
```csharp
using System.Net.Http;
using Biosero.DataServices.Client;

// Create HttpClient with base address
var httpClient = new HttpClient();
httpClient.BaseAddress = new Uri("http://localhost:8105/");

// Initialize the client
var client = new DataServicesClient(httpClient);
```

**Advanced Configuration:**
```csharp
// Configure HttpClient with authentication and timeouts
var httpClient = new HttpClient();
httpClient.BaseAddress = new Uri("https://api.biosero.com/");
httpClient.DefaultRequestHeaders.Authorization = 
    new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", "your-token");
httpClient.Timeout = TimeSpan.FromMinutes(5);

var client = new DataServicesClient(httpClient);
```

## üìä Analytics Methods

### GetOrderCompletionPlotlyChart()

Retrieves order completion chart data for visualization with Plotly.

**Signatures:**
```csharp
ICollection<PlotlyChartData> GetOrderCompletionPlotlyChart()
Task<ICollection<PlotlyChartData>> GetOrderCompletionPlotlyChartAsync(CancellationToken cancellationToken = default)
```

**Returns:**
- `ICollection&lt;PlotlyChartData&gt;`: Chart data formatted for Plotly visualization

**Example:**
```csharp
try
{
    var chartData = await client.GetOrderCompletionPlotlyChartAsync();
    
    foreach (var dataPoint in chartData)
    {
        Console.WriteLine($"X: {dataPoint.X}, Y: {dataPoint.Y}");
    }
}
catch (DataServicesException ex)
{
    Console.WriteLine($"Error retrieving chart data: {ex.Message}");
}
```

## ‚öôÔ∏è Application Configuration Methods

### Azure Active Directory Configuration

```csharp
AzureActiveDirectoryConfiguration GetAzureActiveDirectoryConfiguration()
Task<AzureActiveDirectoryConfiguration> GetAzureActiveDirectoryConfigurationAsync(CancellationToken cancellationToken = default)
```

### Cloud Services Configuration

```csharp
CloudServicesConfiguration GetCloudServicesConfiguration()
Task<CloudServicesConfiguration> GetCloudServicesConfigurationAsync(CancellationToken cancellationToken = default)
```

### Conductor Auto Refresh Switch

```csharp
ConductorAutoRefreshSwitch GetConductorAutoRefreshSwitch(string cacheControl = null)
Task<ConductorAutoRefreshSwitch> GetConductorAutoRefreshSwitchAsync(string cacheControl = null, CancellationToken cancellationToken = default)

void UpdateConductorAutoRefreshSwitch(UpdateConductorAutoRefreshSwitchCommand body)
Task UpdateConductorAutoRefreshSwitchAsync(UpdateConductorAutoRefreshSwitchCommand body, CancellationToken cancellationToken = default)
```

### Conductor License Configuration

```csharp
ConductorLicenseConfiguration GetConductorLicenseConfiguration()
Task<ConductorLicenseConfiguration> GetConductorLicenseConfigurationAsync(CancellationToken cancellationToken = default)
```

### Host Environment

```csharp
HostEnvironmentNameOnly GetHostEnvironment()
Task<HostEnvironmentNameOnly> GetHostEnvironmentAsync(CancellationToken cancellationToken = default)
```

### Maintenance Mode Switch

```csharp
MaintenanceModeSwitch GetMaintenanceModeSwitch()
Task<MaintenanceModeSwitch> GetMaintenanceModeSwitchAsync(CancellationToken cancellationToken = default)
```

### Queues Enabled

```csharp
QueuesEnabledOnly GetQueuesEnabled()
Task<QueuesEnabledOnly> GetQueuesEnabledAsync(CancellationToken cancellationToken = default)
```

### Transportation Manager Switch

```csharp
TransportationManagerSwitch GetTransportationManagerSwitch()
Task<TransportationManagerSwitch> GetTransportationManagerSwitchAsync(CancellationToken cancellationToken = default)
```

### Workflow Service Switch

```csharp
WorkflowServiceSwitch GetWorkflowServiceSwitch()
Task<WorkflowServiceSwitch> GetWorkflowServiceSwitchAsync(CancellationToken cancellationToken = default)
```

**Example:**
```csharp
// Get current configuration settings
var azureConfig = await client.GetAzureActiveDirectoryConfigurationAsync();
var hostEnv = await client.GetHostEnvironmentAsync();
var maintenanceMode = await client.GetMaintenanceModeSwitchAsync();

Console.WriteLine($"Environment: {hostEnv.Name}");
Console.WriteLine($"Maintenance Mode: {maintenanceMode.IsEnabled}");
Console.WriteLine($"Azure Tenant: {azureConfig.TenantId}");
```

## üì¶ Event Management Methods

### AddEvent()

Adds and publishes an event via the Event Processor.

```csharp
EventIdOnly AddEvent(AddEventCommand body)
Task<EventIdOnly> AddEventAsync(AddEventCommand body, CancellationToken cancellationToken = default)
```

**Parameters:**
- `body` (AddEventCommand): The event data to add

**Returns:**
- `EventIdOnly`: The ID of the created event

### GetEvents()

Retrieves events ordered by created date with optional filtering.

```csharp
ICollection<EventMessage> GetEvents(
    DateTimeOffset? createdFrom = null,
    DateTimeOffset? createdTo = null,
    string createdAfterEventId = null,
    string topic = null,
    int? limit = null,
    int? offset = null)

Task<ICollection<EventMessage>> GetEventsAsync(
    DateTimeOffset? createdFrom = null,
    DateTimeOffset? createdTo = null,
    string createdAfterEventId = null,
    string topic = null,
    int? limit = null,
    int? offset = null,
    CancellationToken cancellationToken = default)
```

**Parameters:**
- `createdFrom` (DateTimeOffset?): Events created on or after this date
- `createdTo` (DateTimeOffset?): Events created on or before this date
- `createdAfterEventId` (string): Events created after this event ID
- `topic` (string): Filter by event topic
- `limit` (int?): Maximum number of events (default: 100, max: 100)
- `offset` (int?): Pagination offset (default: 0)

### GetEvent()

Retrieves a specific event by ID.

```csharp
EventMessage GetEvent(string eventId)
Task<EventMessage> GetEventAsync(string eventId, CancellationToken cancellationToken = default)
```

### GetEventsPage()

Retrieves events with pagination metadata.

```csharp
EventMessagePage GetEventsPage(
    DateTimeOffset? createdFrom = null,
    DateTimeOffset? createdTo = null,
    string topic = null,
    int? limit = null,
    int? offset = null)

Task<EventMessagePage> GetEventsPageAsync(
    DateTimeOffset? createdFrom = null,
    DateTimeOffset? createdTo = null,
    string topic = null,
    int? limit = null,
    int? offset = null,
    CancellationToken cancellationToken = default)
```

### GetEventTopics()

Retrieves available event topics.

```csharp
ICollection<string> GetEventTopics(
    DateTimeOffset? createdFrom = null,
    DateTimeOffset? createdTo = null)

Task<ICollection<string>> GetEventTopicsAsync(
    DateTimeOffset? createdFrom = null,
    DateTimeOffset? createdTo = null,
    CancellationToken cancellationToken = default)
```

**Example:**
```csharp
// Add a new event
var addEventCommand = new AddEventCommand
{
    Topic = "Biosero.DataModels.Events.InstrumentOperationEvent",
    Data = "{\"instrumentName\":\"Hamilton STAR\",\"operation\":\"aspirate\"}",
    AssociationId = "lab-001",
    ModuleId = "liquid-handler-01"
};

var eventId = await client.AddEventAsync(addEventCommand);
Console.WriteLine($"Created event: {eventId.Id}");

// Retrieve recent events
var recentEvents = await client.GetEventsAsync(
    createdFrom: DateTimeOffset.Now.AddHours(-1),
    limit: 50
);

Console.WriteLine($"Found {recentEvents.Count} recent events");

// Get events with pagination
var eventPage = await client.GetEventsPageAsync(
    topic: "Biosero.DataModels.Events.InstrumentOperationEvent",
    limit: 25,
    offset: 0
);

Console.WriteLine($"Page {eventPage.PageNumber}: {eventPage.Events.Count} events");
Console.WriteLine($"Total events: {eventPage.TotalCount}");
```

## üìÅ File Management Methods

### GetFile()

Downloads a file by type and identifier.

```csharp
FileResponse GetFile(FileType fileType, string identifier, string cacheControl = null)
Task<FileResponse> GetFileAsync(FileType fileType, string identifier, string cacheControl = null, CancellationToken cancellationToken = default)
```

**Parameters:**
- `fileType` (FileType): The type of file to retrieve
- `identifier` (string): The file identifier
- `cacheControl` (string): Cache control header value

### GetFileMetadata()

Retrieves metadata for a file without downloading the content.

```csharp
FileMetadata GetFileMetadata(FileType fileType, string identifier, string cacheControl = null)
Task<FileMetadata> GetFileMetadataAsync(FileType fileType, string identifier, string cacheControl = null, CancellationToken cancellationToken = default)
```

**Example:**
```csharp
// Get file metadata
var metadata = await client.GetFileMetadataAsync(
    FileType.AnalysisResult,
    "analysis-123"
);

Console.WriteLine($"File: {metadata.FileName}");
Console.WriteLine($"Size: {metadata.Size} bytes");
Console.WriteLine($"Content Type: {metadata.ContentType}");

// Download the file
var fileResponse = await client.GetFileAsync(
    FileType.AnalysisResult,
    "analysis-123"
);

// Save to disk
await File.WriteAllBytesAsync("analysis-result.pdf", fileResponse.Stream.ToArray());
```

## üß¨ Identity Management Methods

### GetIdentities()

Retrieves identities with optional filtering and pagination.

```csharp
ICollection<Identity> GetIdentities(
    string name = null,
    string typeIdentifier = null,
    int? limit = null,
    int? offset = null)

Task<ICollection<Identity>> GetIdentitiesAsync(
    string name = null,
    string typeIdentifier = null,
    int? limit = null,
    int? offset = null,
    CancellationToken cancellationToken = default)
```

**Parameters:**
- `name` (string): Filter by identity name
- `typeIdentifier` (string): Filter by type identifier
- `limit` (int?): Maximum records to return (default: 100)
- `offset` (int?): Pagination offset (default: 0)

**Example:**
```csharp
// Get all plate identities
var plateIdentities = await client.GetIdentitiesAsync(
    typeIdentifier: "Plate",
    limit: 100
);

foreach (var identity in plateIdentities)
{
    Console.WriteLine($"Plate: {identity.Name} (ID: {identity.Identifier})");
}

// Search for specific identity by name
var specificIdentities = await client.GetIdentitiesAsync(
    name: "Sample-001"
);
```

## ÔøΩ Individual Identity Operations

The DataServicesClient provides comprehensive methods for managing individual identities, including retrieval, location tracking, and removal operations.

### GetIdentity()

Retrieves a specific identity by its identifier.

```csharp
Identity GetIdentity(string identifier)
Task<Identity> GetIdentityAsync(string identifier, CancellationToken cancellationToken = default)
```

**Parameters:**
- `identifier` (string): The unique identifier of the identity

**Returns:**
- `Identity`: The identity object with full details

### RemoveIdentity()

Removes an identity from the system.

```csharp
void RemoveIdentity(string identifier)
Task RemoveIdentityAsync(string identifier, CancellationToken cancellationToken = default)
```

**Parameters:**
- `identifier` (string): The unique identifier of the identity to remove

### GetIdentityLocation()

Retrieves the current location information for a specific identity.

```csharp
Location GetIdentityLocation(string identifier)
Task<Location> GetIdentityLocationAsync(string identifier, CancellationToken cancellationToken = default)
```

**Parameters:**
- `identifier` (string): The unique identifier of the identity

**Returns:**
- `Location`: The current location of the identity

### GetIdentityLocationPath()

Retrieves the location path for a specific identity.

```csharp
void GetIdentityLocationPath(string identifier)
Task GetIdentityLocationPathAsync(string identifier, CancellationToken cancellationToken = default)
```

**Example:**
```csharp
// Get detailed identity information
var identity = await client.GetIdentityAsync("PLATE-001");
Console.WriteLine($"Identity: {identity.Name}, Type: {identity.TypeIdentifier}");

// Get current location
var location = await client.GetIdentityLocationAsync("PLATE-001");
Console.WriteLine($"Current Location: {location.Name}");

// Remove identity when no longer needed
await client.RemoveIdentityAsync("PLATE-001");
Console.WriteLine("Identity removed successfully");
```

## ‚öñÔ∏è Weight and Volume Management

The DataServicesClient includes specialized methods for tracking weight and volume measurements of containers and laboratory items.

### GetContainerNetWeightFromTransfers()

Calculates the net weight of a container based on transfer operations.

```csharp
Weight GetContainerNetWeightFromTransfers(string containerId)
Task<Weight> GetContainerNetWeightFromTransfersAsync(string containerId, CancellationToken cancellationToken = default)
```

**Parameters:**
- `containerId` (string): The unique identifier of the container

**Returns:**
- `Weight`: The calculated net weight of the container

### GetWeightEvents()

Retrieves weight measurement events for a specific container.

```csharp
ICollection<WeightEvent> GetWeightEvents(
    string containerId,
    WeightMeasurementType? measurementType = null,
    DateTimeOffset? start = null,
    DateTimeOffset? end = null,
    int? limit = null,
    int? offset = null)

Task<ICollection<WeightEvent>> GetWeightEventsAsync(
    string containerId,
    WeightMeasurementType? measurementType = null,
    DateTimeOffset? start = null,
    DateTimeOffset? end = null,
    int? limit = null,
    int? offset = null,
    CancellationToken cancellationToken = default)
```

**Parameters:**
- `containerId` (string): The container identifier
- `measurementType` (WeightMeasurementType?): Optional filter by measurement type
- `start` (DateTimeOffset?): Start date for filtering events
- `end` (DateTimeOffset?): End date for filtering events
- `limit` (int?): Maximum number of events to return
- `offset` (int?): Pagination offset

**Returns:**
- `ICollection&lt;WeightEvent&gt;`: Collection of weight measurement events

**Example:**
```csharp
// Get container net weight from transfers
var weight = await client.GetContainerNetWeightFromTransfersAsync("CONTAINER-123");
Console.WriteLine($"Net Weight: {weight.Value} {weight.Unit}");

// Get recent weight events
var weightEvents = await client.GetWeightEventsAsync(
    "CONTAINER-123",
    measurementType: WeightMeasurementType.Net,
    start: DateTimeOffset.Now.AddDays(-7),
    limit: 50
);

foreach (var weightEvent in weightEvents)
{
    Console.WriteLine($"Weight Event: {weightEvent.Weight.Value} {weightEvent.Weight.Unit} at {weightEvent.Timestamp}");
}
```

## üîÑ Additional API Methods

**Note:** The DataServicesClient is a comprehensive API with over 200+ methods covering various aspects of laboratory data management. The sections above cover the most commonly used functionality. The complete API includes additional specialized methods for:

### Additional Functional Areas:
- **Order Management**: Creating, updating, and tracking laboratory orders
- **Sample Management**: Detailed sample tracking and lifecycle management  
- **Workflow Operations**: Laboratory workflow automation and monitoring
- **Equipment Integration**: Instrument and device communication interfaces
- **Data Analytics**: Advanced reporting and analysis capabilities
- **Audit and Compliance**: Comprehensive logging and traceability features
- **Location Services**: Advanced positioning and tracking systems
- **Protocol Management**: Laboratory protocol execution and monitoring
- **Quality Control**: QC sample processing and validation
- **Inventory Management**: Laboratory inventory tracking and management

### Method Categories Not Fully Documented:
- Transfer operations and liquid handling
- Barcode and RFID management  
- Temperature and environmental monitoring
- Calibration and maintenance tracking
- User and permission management
- Integration with external systems
- Real-time monitoring and alerting
- Batch processing operations

**For complete API reference**: The auto-generated client contains the full method signatures with XML documentation. Refer to IntelliSense in your IDE or the generated client source code for detailed information about all available methods.

## ÔøΩüìä Laboratory Data Methods

### GetContainerNetVolume()

Retrieves the net volume for a specific container.

```csharp
Volume GetContainerNetVolume(string containerId)
Task<Volume> GetContainerNetVolumeAsync(string containerId, CancellationToken cancellationToken = default)
```

**Parameters:**
- `containerId` (string): The container identifier

**Returns:**
- `Volume`: The net volume of the container

**Example:**
```csharp
// Get container volume
var volume = await client.GetContainerNetVolumeAsync("container-123");

Console.WriteLine($"Container Volume: {volume.Value} {volume.Unit}");
```

## ‚ö†Ô∏è Error Handling

The DataServicesClient uses a custom exception hierarchy for error handling:

### DataServicesException

Base exception class for all API errors.

**Properties:**
- `StatusCode` (int): HTTP status code
- `Response` (string): Raw response content
- `Headers` (IDictionary&lt;string, IEnumerable&lt;string&gt;&gt;): Response headers

### DataServicesException&lt;T&gt;

Generic exception that includes a strongly-typed error object.

**Properties:**
- `Result` (T): Strongly-typed error object (e.g., ProblemDetails)

### Common Error Scenarios

```csharp
try
{
    var events = await client.GetEventsAsync();
}
catch (DataServicesException<ProblemDetails> ex) when (ex.StatusCode == 400)
{
    // Bad Request with detailed error information
    Console.WriteLine($"Validation Error: {ex.Result.Title}");
    Console.WriteLine($"Details: {ex.Result.Detail}");
}
catch (DataServicesException ex) when (ex.StatusCode == 401)
{
    // Unauthorized
    Console.WriteLine("Authentication required");
}
catch (DataServicesException ex) when (ex.StatusCode == 403)
{
    // Forbidden
    Console.WriteLine("Access denied");
}
catch (DataServicesException ex) when (ex.StatusCode == 404)
{
    // Not Found
    Console.WriteLine("Resource not found");
}
catch (HttpRequestException ex)
{
    // Network or connection errors
    Console.WriteLine($"Network error: {ex.Message}");
}
catch (TaskCanceledException ex)
{
    // Timeout or cancellation
    Console.WriteLine($"Request timeout: {ex.Message}");
}
```

## üìñ Examples

### Example 1: Complete Application Configuration Audit

```csharp
using Biosero.DataServices.Client;
using System.Net.Http;

public class ConfigurationAuditor
{
    private readonly DataServicesClient _client;

    public ConfigurationAuditor(string baseUrl)
    {
        var httpClient = new HttpClient { BaseAddress = new Uri(baseUrl) };
        _client = new DataServicesClient(httpClient);
    }

    public async Task AuditConfigurationsAsync()
    {
        try
        {
            // Get all configuration settings
            var hostEnv = await _client.GetHostEnvironmentAsync();
            var azureConfig = await _client.GetAzureActiveDirectoryConfigurationAsync();
            var cloudConfig = await _client.GetCloudServicesConfigurationAsync();
            var maintenanceMode = await _client.GetMaintenanceModeSwitchAsync();
            var autoRefresh = await _client.GetConductorAutoRefreshSwitchAsync();
            var queuesEnabled = await _client.GetQueuesEnabledAsync();

            // Generate audit report
            Console.WriteLine("=== Configuration Audit Report ===");
            Console.WriteLine($"Host Environment: {hostEnv.Name}");
            Console.WriteLine($"Maintenance Mode: {(maintenanceMode.IsEnabled ? "ENABLED" : "Disabled")}");
            Console.WriteLine($"Auto Refresh: {(autoRefresh.IsEnabled ? "ENABLED" : "Disabled")}");
            Console.WriteLine($"Queues: {(queuesEnabled.IsEnabled ? "ENABLED" : "Disabled")}");
            Console.WriteLine($"Azure Tenant: {azureConfig.TenantId}");
            Console.WriteLine($"Azure Client: {azureConfig.ClientId}");
        }
        catch (DataServicesException ex)
        {
            Console.WriteLine($"Configuration audit failed: {ex.Message} (Status: {ex.StatusCode})");
        }
    }
}
```

### Example 2: Event Monitoring Service

```csharp
public class EventMonitoringService
{
    private readonly DataServicesClient _client;
    private readonly Timer _timer;

    public EventMonitoringService(DataServicesClient client)
    {
        _client = client;
        _timer = new Timer(MonitorEvents, null, TimeSpan.Zero, TimeSpan.FromSeconds(30));
    }

    private async void MonitorEvents(object state)
    {
        try
        {
            var since = DateTime.UtcNow.AddMinutes(-1);
            var recentEvents = await _client.GetEventsAsync(
                createdFrom: since,
                limit: 100
            );

            if (recentEvents.Any())
            {
                Console.WriteLine($"[{DateTime.Now}] Found {recentEvents.Count} new events");
                
                foreach (var evt in recentEvents)
                {
                    Console.WriteLine($"  - {evt.Topic} at {evt.CreatedAt}");
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Event monitoring error: {ex.Message}");
        }
    }

    public void Dispose()
    {
        _timer?.Dispose();
    }
}
```

### Example 3: Bulk Event Processing

```csharp
public class BulkEventProcessor
{
    private readonly DataServicesClient _client;

    public BulkEventProcessor(DataServicesClient client)
    {
        _client = client;
    }

    public async Task ProcessEventsAsync(string topic, DateTimeOffset from, DateTimeOffset to)
    {
        const int pageSize = 100;
        int offset = 0;
        int totalProcessed = 0;

        while (true)
        {
            try
            {
                var eventPage = await _client.GetEventsPageAsync(
                    createdFrom: from,
                    createdTo: to,
                    topic: topic,
                    limit: pageSize,
                    offset: offset
                );

                if (!eventPage.Events.Any())
                    break;

                // Process events
                foreach (var evt in eventPage.Events)
                {
                    await ProcessSingleEventAsync(evt);
                    totalProcessed++;
                }

                Console.WriteLine($"Processed page {eventPage.PageNumber}: {eventPage.Events.Count} events");
                
                offset += pageSize;

                // Check if we've processed all events
                if (offset >= eventPage.TotalCount)
                    break;
            }
            catch (DataServicesException ex)
            {
                Console.WriteLine($"Error processing events: {ex.Message}");
                break;
            }
        }

        Console.WriteLine($"Total events processed: {totalProcessed}");
    }

    private async Task ProcessSingleEventAsync(EventMessage evt)
    {
        // Custom event processing logic
        Console.WriteLine($"Processing event {evt.Id}: {evt.Topic}");
        
        // Simulate processing time
        await Task.Delay(10);
    }
}
```

### Example 4: File Management Operations

```csharp
public class FileManager
{
    private readonly DataServicesClient _client;

    public FileManager(DataServicesClient client)
    {
        _client = client;
    }

    public async Task DownloadAndAnalyzeFileAsync(FileType fileType, string identifier)
    {
        try
        {
            // Get file metadata first
            var metadata = await _client.GetFileMetadataAsync(fileType, identifier);
            Console.WriteLine($"File: {metadata.FileName} ({metadata.Size} bytes)");

            // Check if file is too large
            if (metadata.Size > 10 * 1024 * 1024) // 10MB
            {
                Console.WriteLine("File too large for processing");
                return;
            }

            // Download the file
            var fileResponse = await _client.GetFileAsync(fileType, identifier);
            
            // Save to temporary location
            var tempPath = Path.GetTempFileName();
            await File.WriteAllBytesAsync(tempPath, fileResponse.Stream.ToArray());

            Console.WriteLine($"File downloaded to: {tempPath}");

            // Perform analysis
            await AnalyzeFileAsync(tempPath, metadata.ContentType);

            // Cleanup
            File.Delete(tempPath);
        }
        catch (DataServicesException ex)
        {
            Console.WriteLine($"File operation failed: {ex.Message}");
        }
    }

    private async Task AnalyzeFileAsync(string filePath, string contentType)
    {
        // Custom file analysis logic based on content type
        switch (contentType)
        {
            case "application/json":
                await AnalyzeJsonFileAsync(filePath);
                break;
            case "text/csv":
                await AnalyzeCsvFileAsync(filePath);
                break;
            default:
                Console.WriteLine($"Analysis not supported for {contentType}");
                break;
        }
    }

    private async Task AnalyzeJsonFileAsync(string filePath)
    {
        var content = await File.ReadAllTextAsync(filePath);
        // JSON analysis logic
        Console.WriteLine($"JSON file contains {content.Length} characters");
    }

    private async Task AnalyzeCsvFileAsync(string filePath)
    {
        var lines = await File.ReadAllLinesAsync(filePath);
        // CSV analysis logic
        Console.WriteLine($"CSV file contains {lines.Length} rows");
    }
}
```

## üéØ Best Practices

### 1. **HttpClient Management**

```csharp
// ‚úÖ Good - Use HttpClientFactory or singleton HttpClient
public class DataServicesClientFactory
{
    private static readonly HttpClient _httpClient = new HttpClient();
    
    public static DataServicesClient CreateClient(string baseUrl)
    {
        _httpClient.BaseAddress = new Uri(baseUrl);
        return new DataServicesClient(_httpClient);
    }
}

// ‚ùå Avoid - Creating new HttpClient instances frequently
// This can lead to socket exhaustion
var client = new DataServicesClient(new HttpClient());
```

### 2. **Async/Await Usage**

```csharp
// ‚úÖ Good - Use async methods with proper cancellation
public async Task<ICollection<EventMessage>> GetEventsWithTimeoutAsync(int timeoutSeconds = 30)
{
    using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(timeoutSeconds));
    return await _client.GetEventsAsync(cancellationToken: cts.Token);
}

// ‚ùå Avoid - Blocking async calls
var events = _client.GetEventsAsync().Result; // Can cause deadlocks
```

### 3. **Error Handling Strategy**

```csharp
// ‚úÖ Good - Specific exception handling with retry logic
public async Task<T> ExecuteWithRetryAsync<T>(Func<Task<T>> operation, int maxRetries = 3)
{
    for (int i = 0; i <= maxRetries; i++)
    {
        try
        {
            return await operation();
        }
        catch (DataServicesException ex) when (ex.StatusCode >= 500 && i < maxRetries)
        {
            // Retry on server errors
            await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, i))); // Exponential backoff
        }
        catch (DataServicesException ex) when (ex.StatusCode < 500)
        {
            // Don't retry client errors
            throw;
        }
    }
    
    throw new InvalidOperationException("Operation failed after maximum retries");
}
```

### 4. **Pagination Handling**

```csharp
// ‚úÖ Good - Proper pagination with bounds checking
public async Task<List<EventMessage>> GetAllEventsAsync(string topic)
{
    var allEvents = new List<EventMessage>();
    const int pageSize = 100;
    int offset = 0;

    while (true)
    {
        var page = await _client.GetEventsPageAsync(
            topic: topic,
            limit: pageSize,
            offset: offset
        );

        if (!page.Events.Any())
            break;

        allEvents.AddRange(page.Events);
        offset += pageSize;

        // Safety check to prevent infinite loops
        if (offset >= page.TotalCount || allEvents.Count >= 10000)
            break;
    }

    return allEvents;
}
```

### 5. **Resource Management**

```csharp
// ‚úÖ Good - Proper disposal of resources
public class DataServicesManager : IDisposable
{
    private readonly HttpClient _httpClient;
    private readonly DataServicesClient _client;

    public DataServicesManager(string baseUrl)
    {
        _httpClient = new HttpClient { BaseAddress = new Uri(baseUrl) };
        _client = new DataServicesClient(_httpClient);
    }

    public async Task<FileResponse> DownloadFileAsync(FileType fileType, string identifier)
    {
        return await _client.GetFileAsync(fileType, identifier);
    }

    public void Dispose()
    {
        _httpClient?.Dispose();
    }
}
```

### 6. **Configuration Management**

```csharp
// ‚úÖ Good - Centralized configuration with validation
public class DataServicesConfig
{
    public string BaseUrl { get; set; }
    public string ApiKey { get; set; }
    public int TimeoutSeconds { get; set; } = 30;
    
    public void Validate()
    {
        if (string.IsNullOrEmpty(BaseUrl))
            throw new ArgumentException("BaseUrl is required");
        
        if (!Uri.TryCreate(BaseUrl, UriKind.Absolute, out _))
            throw new ArgumentException("BaseUrl must be a valid URI");
    }
}

public class ConfiguredDataServicesClient
{
    private readonly DataServicesClient _client;
    
    public ConfiguredDataServicesClient(DataServicesConfig config)
    {
        config.Validate();
        
        var httpClient = new HttpClient
        {
            BaseAddress = new Uri(config.BaseUrl),
            Timeout = TimeSpan.FromSeconds(config.TimeoutSeconds)
        };
        
        if (!string.IsNullOrEmpty(config.ApiKey))
        {
            httpClient.DefaultRequestHeaders.Authorization = 
                new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", config.ApiKey);
        }
        
        _client = new DataServicesClient(httpClient);
    }
}
```

### 7. **Logging and Monitoring**

```csharp
// ‚úÖ Good - Comprehensive logging
public class LoggedDataServicesClient
{
    private readonly DataServicesClient _client;
    private readonly ILogger _logger;

    public LoggedDataServicesClient(DataServicesClient client, ILogger logger)
    {
        _client = client;
        _logger = logger;
    }

    public async Task<ICollection<EventMessage>> GetEventsAsync(string topic = null)
    {
        var stopwatch = Stopwatch.StartNew();
        
        try
        {
            _logger.LogInformation("Retrieving events with topic: {Topic}", topic ?? "all");
            
            var events = await _client.GetEventsAsync(topic: topic);
            
            _logger.LogInformation("Retrieved {Count} events in {ElapsedMs}ms", 
                events.Count, stopwatch.ElapsedMilliseconds);
                
            return events;
        }
        catch (DataServicesException ex)
        {
            _logger.LogError(ex, "Failed to retrieve events. Status: {StatusCode}, Response: {Response}", 
                ex.StatusCode, ex.Response);
            throw;
        }
        finally
        {
            stopwatch.Stop();
        }
    }
}
```

---

*The DataServicesClient provides comprehensive access to all Biosero Data Services functionality with strong typing, full async support, and robust error handling for building reliable laboratory automation applications.*

</Protected>